异步加载是现在已经不是一个热门的话题了。 虽然不热门了，但他更成为了每一个JSer的基本功。 再次看玉伯博客上推seajs的文章和第一次看的心情已经大有不同。特别是玉伯博客 [这篇文章](https://www.douban.com/note/283566440/)。

我学习seajs已经是3年前的时候了，还记得当时看到异步加载觉得很NB。看了那篇文章后觉得seajs ‘as lazy as possible' 明显比requirejs 要好...
现在看看评论区大家就知道两个东西真正的区别了。

***

### 言归正传
用更科学的方式来区分amd（requirejs）， cmd（seajs）， commonJS

首先站在框架设计者的角度，思考一个模块加载器要做什么事

0、分析模块代码依赖的文件
1、下载文件
2、 JS加载文件

现在我们考虑一种seajs和commonJS中的场景
```
\\ a.js
if(flag){
require('b');
}else{
require('c');
}
```
上面代码 b和c 只有一个会执行。 那么我们这两个文件是否都需要去下载？ 

动手实践发现seaj 把两个文件都下载了。 但只加载了一个文件。
commonjs因为不需要考虑下载，文件都在本地。所以自然是同步执行代码，用到了再去本地加载执行。

***
再看requireJS的场景

```
require(['b','c'], function(b,c){
if( flag ){
  b();
}else{
  c();
}
});
```

在动手得知， requirejs也是都下载了2个文件，并且b和c都被JS加载了。

这里的加载指的是b和c在使用到之前已经是一个对象。
而在seajs中 到 var b = require('b') ；这行之前 b文件只是一个字符串。

requirejs转化为seajs相当于
```
\\ a.js
var b =  require('b');
var c = require('c');
...
1000行代码
...
if(flag){
 c();
}else{
 b();
}
```
这两个的区别现在就显而易见了。 requirejs 在模块被使用到之前就先准备好。 seajs在用到的时候再去准备模块。

这里我们可以发现seajs 比 requirejs 少做了没用的事，更有效率。

但是我们再考虑一种特殊情况比如c模块中如果会报错。
那requirejs在一开始就 抛出了错误。
而seajs在执行到的时候抛出错误。
但是！ 注意那1000行代码。 如果c报错了， 那1000行代码还有必要执行吗？我们还能回滚那1000行代码吗？

这里我们就真正理解了requirejs这样设计的原因。seajs用好了能更加极致，用不好就会出上面这种可怕的错误。

***
现在我们已经知道设计一个模块加载器要做什么和需要注意的点了。
让我们做个整理。

如果在node端不需要下载文件。 我们则让代码同步加载 即Commonjs。

如果在浏览器端， 则都需要提早下载文件， 执行到一半去下载1秒钟这可不行。当然我们可以提供异步下载的实现， require.async 。
下载完文件后是否应该先提前准备模块？ 是 AMD， 否CMD。

希望看完你可以知道你需要哪一种了。
